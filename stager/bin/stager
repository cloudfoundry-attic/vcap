#!/usr/bin/env ruby
ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __FILE__)

require 'rubygems'
require 'bundler/setup'

$LOAD_PATH.unshift(File.expand_path('../../lib', __FILE__))

require 'vcap/common'
require 'vcap/component'
require 'vcap/concurrency'
require 'vcap/stager'

if ENV["CLOUD_FOUNDRY_CONFIG_PATH"]
  config_file = File.join(ENV["CLOUD_FOUNDRY_CONFIG_PATH"], "stager.yml")
else
  config_file = VCAP::Stager::Config::DEFAULT_CONFIG_PATH
end

OptionParser.new do |op|
  op.on('-c', '--config [FILENAME]', 'Config filename') do |val|
    config_file = val
  end
end.parse!

begin
  config = VCAP::Stager::Config.from_file(config_file)
rescue VCAP::JsonSchema::ValidationError => ve
  puts "ERROR: There was a problem validating the supplied config: #{ve}"
  exit 1
rescue => e
  puts "ERROR: Failed loading config from file '#{config_file}': #{e}"
  exit 1
end

begin
  pid_file = VCAP::PidFile.new(config[:pid_filename])
  pid_file.unlink_at_exit
rescue => e
  puts "ERROR: Can't create stager pid file #{config[:pid_filename]}"
  exit 1
end

if config[:tmpdir]
  ENV["TMPDIR"] = config[:tmpdir]
elsif config[:dirs][:tmp]
  # Support old-style configs
  ENV["TMPDIR"] = config[:dirs][:tmp]
end

VCAP::Logging.setup_from_config(config[:logging])

if config[:plugin_runner]
  plugin_runner_factory = nil
  pr_type = config[:plugin_runner][:type]
  pr_config = config[:plugin_runner][:config].dup
else
  # Support old-style configs
  pr_type = "user"
  pr_config = {
    :secure          => config[:secure],
    :ruby_path       => config[:ruby_path],
    :manifest_root   => config[:dirs][:manifests],
    :run_plugin_path => config[:run_plugin_path],
  }
end

case pr_type
when "warden"
  plugin_runner_factory = lambda do
    VCAP::Stager::PluginRunner::WardenBased.new(pr_config)
  end

when "user"
  if pr_config[:secure]
    VCAP::Stager::SecureUserManager.instance.setup

    pr_config[:user_manager] =
      VCAP::Concurrency::Proxy.new(VCAP::Stager::SecureUserManager.instance)
  end

  plugin_runner_factory = lambda do
    VCAP::Stager::PluginRunner::UserBased.new(pr_config)
  end

else
  puts "ERROR: Unknown plugin_runner type: #{pr_type}"
  exit 1
end

thread_pool = VCAP::Concurrency::ThreadPool.new(config[:max_active_tasks])

server = VCAP::Stager::Server.new(config[:nats_uri],
                                  thread_pool,
                                  plugin_runner_factory,
                                  config)

server.run
